package stonering.generators.worldgen.generators.drainage;

import stonering.generators.worldgen.WorldGenContainer;
import stonering.generators.worldgen.generators.WorldGenerator;
import stonering.util.geometry.Position;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

/**
 * Expands lakes points generated by {@link RiverGenerator}
 *
 * @author Alexander Kuzyakov on 01.09.2018.
 */
public class LakeGenerator extends WorldGenerator {
    private ArrayList<Lake> lakes;

    @Override
    public void set(WorldGenContainer container) {
        lakes = new ArrayList<>();
    }

    @Override
    public void run() {
        System.out.println("generating lakes");
        container.getLakes().forEach(position -> lakes.add(new Lake(position)));
        container.getLakes().clear();
        lakes.forEach(this::expandLake);
        lakes.forEach(this::normalizeLakeElavation);
        lakes.forEach(lake -> container.getLakes().addAll(lake.positions));
    }

    /**
     * Finds lowest points around lakePoint to expand to.
     */
    private void expandLake(Lake lake) {
        HashSet<Position> neighbours = new HashSet<>();
        Position position = lake.startPos;
        lake.positions.add(position);
        addNewNeighbours(position, neighbours);
        int lakeSize = getLakeSize(position.x, position.y);
        for (int i = 0; i < lakeSize; i++) {
            Position newPosition = getLowestPosition(neighbours, lake.positions);
            if (container.getElevation(newPosition) < container.config.seaLevel) {
                break;
            }
            lake.positions.add(newPosition);
            addNewNeighbours(newPosition, neighbours);
            neighbours.removeAll(lake.positions);
        }
    }

    /**
     * Lowers elevation of all lake points to minimal.
     *
     * @param lake
     */
    private void normalizeLakeElavation(Lake lake) {
        float minElevation = container.getElevation(Collections.min(lake.positions, (o1, o2) -> {
                    return Math.round(Math.signum(container.getElevation(o1) - container.getElevation(o2)));
                }
        ));
        lake.positions.forEach(position -> {
                    container.setElevation(position, minElevation);
                }
        );
    }

    /**
     * Returns lake size based on amount of water from river which forms this lake.
     *
     * @param x
     * @param y
     * @return
     */
    private int getLakeSize(int x, int y) {
        return Math.round(container.getRiver(x, y).len() * 80f);
    }

    private void addNewNeighbours(Position position, HashSet<Position> positions) {
        int cx = position.x;
        int cy = position.y;
        for (int x = Math.round(cx) - 1; x <= cx + 1; x++) {
            for (int y = Math.round(cy) - 1; y <= cy + 1; y++) {
                if ((x != cx || y != cy) && container.inMap(x, y)) {
                    positions.add(new Position(x, y, 0));
                }
            }
        }
    }

    /**
     * Counts expansion function value for all lake neighbours and return position with highest value.
     * @param neighbours
     * @param lake
     * @return
     */
    private Position getLowestPosition(HashSet<Position> neighbours, HashSet<Position> lake) {
        float maxFunction = 0;
        Position bestPosition = null;
        for (Position position : neighbours) {
            float function = getNeighbourFunction(position, lake);
            if (function > maxFunction) {
                maxFunction = function;
                bestPosition = position;
            }
        }
        return bestPosition;
    }

    /**
     * Shows how given position suits for expanding lake.
     * Positions adjacent to lake are more likely to be added.
     * Positions with highest elevation gap are more likely to be added.
     *
     * @param position
     * @param positions
     * @return
     */
    private float getNeighbourFunction(Position position, HashSet<Position> positions) {
        int neighbourPoints = 0;
        float maxElavationDelta = 0;
        for (Position lakePoint : positions) {
            float distance = getDistance(position, lakePoint);
            if (distance > 0) {
                maxElavationDelta = Math.max(container.getElevation(lakePoint) - container.getElevation(position), maxElavationDelta);
            }

            neighbourPoints += distance;
        }
        return neighbourPoints * 0.003f + maxElavationDelta;
    }

    private float getDistance(Position pos1, Position pos2) {
        int x1 = pos1.x;
        int y1 = pos1.y;
        int x2 = pos2.x;
        int y2 = pos2.y;
        if (Math.abs(x1 - x2) > 1 || Math.abs(y1 - y2) > 1) {
            return 0;
        }
        if (x1 != x2 && y1 != y2) {
            return 1.1f;
        }
        return 1;
    }

    private class Lake {
        Position startPos;
        HashSet<Position> positions;

        public Lake(Position startPos) {
            this.startPos = startPos;
            positions = new HashSet<>();
        }
    }
}
